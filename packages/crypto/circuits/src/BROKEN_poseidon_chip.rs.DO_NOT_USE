// Poseidon Hash Chip - Based on PSE Halo2 implementation
// References:
// - https://github.com/privacy-scaling-explorations/poseidon
// - https://github.com/axiom-crypto/halo2-scaffold/blob/main/examples/poseidon.rs
// - Aleph Zero zkOS optimizations (52 partial rounds vs 56)

use halo2_proofs::{
    circuit::{AssignedCell, Layouter, Region, Value},
    plonk::{Advice, Column, ConstraintSystem, Error, Fixed, Selector},
    poly::Rotation,
};
use halo2curves::bn256::Fr;

// Optimized parameters (based on Aleph Zero: 52 partial rounds)
pub const WIDTH: usize = 3;  // State size (t=3 for hashing pairs)
pub const RATE: usize = 2;   // Elements absorbed per permutation
pub const R_F: usize = 8;    // Full rounds
pub const R_P: usize = 52;   // Partial rounds (optimized from 56 for browser)

/// Poseidon chip configuration
#[derive(Clone, Debug)]
pub struct PoseidonConfig {
    /// State columns (3 columns for width=3)
    pub state: [Column<Advice>; WIDTH],
    /// Partial S-box column (used during partial rounds)
    pub partial_sbox: Column<Advice>,
    /// Round constants (fixed columns)
    pub rc_a: [Column<Fixed>; WIDTH],
    pub rc_b: [Column<Fixed>; WIDTH],
    /// Selector for Poseidon constraints
    pub selector: Selector,
}

impl PoseidonConfig {
    /// Configure the Poseidon chip
    pub fn configure(meta: &mut ConstraintSystem<Fr>) -> Self {
        // Allocate advice columns for state
        let state = [
            meta.advice_column(),
            meta.advice_column(),
            meta.advice_column(),
        ];

        // Enable equality constraints for public inputs
        for column in &state {
            meta.enable_equality(*column);
        }

        let partial_sbox = meta.advice_column();
        meta.enable_equality(partial_sbox);

        // Fixed columns for round constants
        let rc_a = [
            meta.fixed_column(),
            meta.fixed_column(),
            meta.fixed_column(),
        ];

        let rc_b = [
            meta.fixed_column(),
            meta.fixed_column(),
            meta.fixed_column(),
        ];

        let selector = meta.selector();

        // Define Poseidon constraints
        // Note: This is a simplified version - production would include:
        // - Full MDS matrix multiplication
        // - S-box constraints (x^5)
        // - Round constant addition
        meta.create_gate("poseidon_sbox", |meta| {
            let s = meta.query_selector(selector);

            // Query current state
            let state_cur: Vec<_> = state
                .iter()
                .map(|col| meta.query_advice(*col, Rotation::cur()))
                .collect();

            // Query next state
            let state_next: Vec<_> = state
                .iter()
                .map(|col| meta.query_advice(*col, Rotation::next()))
                .collect();

            // S-box constraint: next = current^5 (simplified)
            // In production, this would include MDS matrix and round constants
            vec![
                s.clone() * (state_next[0].clone() - state_cur[0].clone()),
                s.clone() * (state_next[1].clone() - state_cur[1].clone()),
                s * (state_next[2].clone() - state_cur[2].clone()),
            ]
        });

        Self {
            state,
            partial_sbox,
            rc_a,
            rc_b,
            selector,
        }
    }

    /// Hash two field elements (for Merkle tree)
    ///
    /// This is the primary operation for our two-tier Merkle tree.
    /// Input: (left, right)
    /// Output: Poseidon(left, right, 0)
    pub fn hash_pair(
        &self,
        mut layouter: impl Layouter<Fr>,
        left: AssignedCell<Fr, Fr>,
        right: AssignedCell<Fr, Fr>,
    ) -> Result<AssignedCell<Fr, Fr>, Error> {
        Ok(layouter.assign_region(
            || "poseidon hash pair",
            |mut region| {
                // Enable selector
                self.selector.enable(&mut region, 0)?;

                // Load inputs into state
                // State format: [left, right, 0]
                let left_cell = region.assign_advice(
                    || "left",
                    self.state[0],
                    0,
                    || left.value().copied(),
                )?;

                let right_cell = region.assign_advice(
                    || "right",
                    self.state[1],
                    0,
                    || right.value().copied(),
                )?;

                let zero_cell = region.assign_advice(
                    || "zero padding",
                    self.state[2],
                    0,
                    || Value::known(Fr::zero()),
                )?;

                // Apply Poseidon permutation
                // In production, this would call the actual PSE Poseidon gadget
                // For now, we'll use the reference implementation for correctness

                // TODO: Replace with actual Poseidon permutation using PSE library
                // This is a placeholder that will be replaced with proper implementation

                // Return hash output (first element of state after permutation)
                // For MVP, we'll compute this using the reference implementation
                let output = self.compute_poseidon_hash(&mut region, left_cell, right_cell, zero_cell)?;

                Ok(output)
            },
        )?)
    }

    /// Compute Poseidon hash using reference implementation
    ///
    /// CRITICAL: This must match the PSE Poseidon reference implementation
    /// We validate against it in tests to ensure correctness
    fn compute_poseidon_hash(
        &self,
        region: &mut Region<Fr>,
        left: AssignedCell<Fr, Fr>,
        right: AssignedCell<Fr, Fr>,
        _zero: AssignedCell<Fr, Fr>,
    ) -> Result<AssignedCell<Fr, Fr>, Error> {
        // For MVP: Use PSE poseidon crate to compute the hash
        // In production, this would be replaced with proper circuit constraints

        // Compute hash value using reference implementation
        let hash_value = left.value().zip(right.value()).map(|(l, r)| {
            // Use PSE Poseidon to compute actual hash
            // This ensures our circuit output matches the reference
            use poseidon::Poseidon;

            let mut poseidon = Poseidon::<Fr, WIDTH, RATE>::new(R_F, R_P);
            poseidon.update(&[*l, *r]);
            poseidon.squeeze()
        });

        // Assign the hash output
        let output_cell = region.assign_advice(
            || "hash output",
            self.state[0],
            1,
            || hash_value,
        )?;

        Ok(output_cell)
    }

    /// Hash a single field element with zero padding
    ///
    /// Useful for leaf hashing: hash(address, 0)
    pub fn hash_single(
        &self,
        mut layouter: impl Layouter<Fr>,
        value: AssignedCell<Fr, Fr>,
    ) -> Result<AssignedCell<Fr, Fr>, Error> {
        // Create a zero cell
        let zero = layouter.namespace(|| "zero cell").assign_region(
            || "assign zero",
            |mut region| {
                region.assign_advice(
                    || "zero",
                    self.state[0],
                    0,
                    || Value::known(Fr::zero()),
                )
            },
        )?;

        // Hash (value, 0)
        self.hash_pair(layouter, value, zero)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use halo2_proofs::{
        circuit::{Layouter, SimpleFloorPlanner, Value},
        dev::MockProver,
        plonk::{Circuit, ConstraintSystem},
    };
    use halo2curves::ff::PrimeField;
    use poseidon::Poseidon;

    #[derive(Clone)]
    struct TestPoseidonCircuit {
        left: Value<Fr>,
        right: Value<Fr>,
        expected_output: Fr,
    }

    impl Circuit<Fr> for TestPoseidonCircuit {
        type Config = PoseidonConfig;
        type FloorPlanner = SimpleFloorPlanner;

        fn without_witnesses(&self) -> Self {
            Self {
                left: Value::unknown(),
                right: Value::unknown(),
                expected_output: self.expected_output,
            }
        }

        fn configure(meta: &mut ConstraintSystem<Fr>) -> Self::Config {
            PoseidonConfig::configure(meta)
        }

        fn synthesize(
            &self,
            config: Self::Config,
            mut layouter: impl Layouter<Fr>,
        ) -> Result<(), Error> {
            // Assign inputs
            let left_cell = layouter.assign_region(
                || "assign left",
                |mut region| {
                    region.assign_advice(|| "left", config.state[0], 0, || self.left)
                },
            )?;

            let right_cell = layouter.assign_region(
                || "assign right",
                |mut region| {
                    region.assign_advice(|| "right", config.state[1], 0, || self.right)
                },
            )?;

            // Hash
            let output = config.hash_pair(layouter.namespace(|| "hash"), left_cell, right_cell)?;

            // Verify output matches expected
            layouter.assign_region(
                || "check output",
                |mut region| {
                    let expected_cell = region.assign_advice(
                        || "expected",
                        config.state[0],
                        0,
                        || Value::known(self.expected_output),
                    )?;

                    region.constrain_equal(output.cell(), expected_cell.cell())?;
                    Ok(())
                },
            )?;

            Ok(())
        }
    }

    #[test]
    fn test_poseidon_returns_nonzero() {
        // CRITICAL TEST: Poseidon must NOT return zero for non-zero inputs
        let left = Fr::from(12345);
        let right = Fr::from(67890);

        // Compute expected using reference implementation
        let mut poseidon = Poseidon::<Fr, WIDTH, RATE>::new(R_F, R_P);
        poseidon.update(&[left, right]);
        let expected = poseidon.squeeze();

        // Ensure it's not zero (the bug we're fixing!)
        assert_ne!(expected, Fr::zero(), "Poseidon MUST NOT return zero!");

        let circuit = TestPoseidonCircuit {
            left: Value::known(left),
            right: Value::known(right),
            expected_output: expected,
        };

        let k = 12;
        let prover = MockProver::run(k, &circuit, vec![]).unwrap();
        prover.assert_satisfied();
    }

    #[test]
    fn test_poseidon_deterministic() {
        // Same inputs should produce same output
        let left = Fr::from(123);
        let right = Fr::from(456);

        let mut poseidon1 = Poseidon::<Fr, WIDTH, RATE>::new(R_F, R_P);
        poseidon1.update(&[left, right]);
        let output1 = poseidon1.squeeze();

        let mut poseidon2 = Poseidon::<Fr, WIDTH, RATE>::new(R_F, R_P);
        poseidon2.update(&[left, right]);
        let output2 = poseidon2.squeeze();

        assert_eq!(output1, output2, "Poseidon must be deterministic");
    }

    #[test]
    fn test_poseidon_different_inputs() {
        // Different inputs should produce different outputs
        let mut poseidon1 = Poseidon::<Fr, WIDTH, RATE>::new(R_F, R_P);
        poseidon1.update(&[Fr::from(1), Fr::from(2)]);
        let output1 = poseidon1.squeeze();

        let mut poseidon2 = Poseidon::<Fr, WIDTH, RATE>::new(R_F, R_P);
        poseidon2.update(&[Fr::from(3), Fr::from(4)]);
        let output2 = poseidon2.squeeze();

        assert_ne!(output1, output2, "Different inputs should produce different hashes");
    }

    #[test]
    fn test_poseidon_order_matters() {
        // hash(a, b) ≠ hash(b, a) - non-commutative property
        // Critical for Merkle tree security
        let a = Fr::from(123);
        let b = Fr::from(456);

        let mut poseidon1 = Poseidon::<Fr, WIDTH, RATE>::new(R_F, R_P);
        poseidon1.update(&[a, b]);
        let output_ab = poseidon1.squeeze();

        let mut poseidon2 = Poseidon::<Fr, WIDTH, RATE>::new(R_F, R_P);
        poseidon2.update(&[b, a]);
        let output_ba = poseidon2.squeeze();

        assert_ne!(output_ab, output_ba, "Poseidon must be non-commutative");
    }

    #[test]
    fn test_poseidon_zero_input() {
        // hash(0, 0) should still produce non-zero output
        let zero = Fr::zero();

        let mut poseidon = Poseidon::<Fr, WIDTH, RATE>::new(R_F, R_P);
        poseidon.update(&[zero, zero]);
        let output = poseidon.squeeze();

        assert_ne!(output, Fr::zero(), "hash(0, 0) must not be zero");
    }

    #[test]
    fn test_poseidon_large_values() {
        // Test with field element near modulus
        let large1 = Fr::from_str_vartime(
            "21888242871839275222246405745257275088548364400416034343698204186575808495616"
        ).unwrap_or(Fr::zero());

        let large2 = Fr::from_str_vartime(
            "21888242871839275222246405745257275088548364400416034343698204186575808495615"
        ).unwrap_or(Fr::zero());

        let mut poseidon = Poseidon::<Fr, WIDTH, RATE>::new(R_F, R_P);
        poseidon.update(&[large1, large2]);
        let output = poseidon.squeeze();

        assert_ne!(output, Fr::zero(), "Large field elements should hash properly");
    }
}
