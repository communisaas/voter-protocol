//! Generate Solidity verifier for district membership circuit (SINGLE-TIER K=14)
//!
//! This script:
//! 1. Loads KZG ceremony parameters (k=14)
//! 2. Runs district_membership_single_tier circuit in keygen mode
//! 3. Generates verifying key
//! 4. Uses snark-verifier to generate EVM verifier bytecode
//! 5. Outputs deployment information to contracts directory
//!
//! Usage:
//!   cargo run --bin generate_verifier --release
//!
//! ğŸ”’ CYPHERPUNK SECURITY POSTURE:
//! This generates the verifier that will verify ALL district proofs on-chain
//! for the next DECADE. We assume:
//! - Nation-state adversaries with unlimited budgets
//! - Supply chain attacks on ALL dependencies (even audited ones)
//! - Zero-day vulnerabilities in Rust compiler, LLVM, CPU microcode
//! - Quantum computers (20+ year timeline, prepare now)
//! - Social engineering attacks on ceremony participants
//!
//! CRYPTOGRAPHIC BINDING: The generated bytecode MUST match the prover's
//! circuit configuration EXACTLY. ONE BIT of mismatch = total system compromise.
//!
//! ARCHITECTURE (2025-10-28):
//! Single-tier K=14 circuit removes global tree, moves districtâ†’country mapping
//! to on-chain DistrictRegistry.sol. Expected: ~12-16KB verifier (fits EIP-170).

use halo2_base::{
    gates::{
        circuit::{CircuitBuilderStage, builder::RangeCircuitBuilder},
        RangeInstructions,
    },
    halo2_proofs::{
        halo2curves::bn256::{Bn256, Fr, G1Affine},
        plonk::{keygen_vk, keygen_pk, ProvingKey, Circuit},
        poly::{
            commitment::Params,
            kzg::commitment::ParamsKZG,
        },
    },
    AssignedValue,
};
use snark_verifier_sdk::CircuitExt;
use std::fs;
use std::path::Path;

const K: u32 = 14; // Single-tier circuit (MUST match prover)
// NOTE: K=12 single-tier attempted but generates 53KB bytecode (29 columns)
// K=14 single-tier expected: ~12-16KB (6-8 columns, FITS EIP-170)

// ğŸ”’ SECURITY: Single-tier circuit with on-chain registry
use voter_district_circuit::district_membership_single_tier::DistrictMembershipCircuit;

/// Minimal circuit wrapper for verifier generation
/// Implements CircuitExt trait required by snark-verifier
#[derive(Clone)]
struct DistrictCircuitForKeygen {
    builder: RangeCircuitBuilder<Fr>,
    public_outputs: Vec<AssignedValue<Fr>>,
}

impl Circuit<Fr> for DistrictCircuitForKeygen {
    type Config = <RangeCircuitBuilder<Fr> as Circuit<Fr>>::Config;
    type FloorPlanner = <RangeCircuitBuilder<Fr> as Circuit<Fr>>::FloorPlanner;
    type Params = <RangeCircuitBuilder<Fr> as Circuit<Fr>>::Params;

    fn params(&self) -> Self::Params {
        self.builder.params()
    }

    fn without_witnesses(&self) -> Self {
        Self {
            builder: self.builder.without_witnesses(),
            public_outputs: self.public_outputs.clone(),
        }
    }

    fn configure_with_params(
        meta: &mut halo2_base::halo2_proofs::plonk::ConstraintSystem<Fr>,
        params: Self::Params,
    ) -> Self::Config {
        RangeCircuitBuilder::configure_with_params(meta, params)
    }

    fn configure(_meta: &mut halo2_base::halo2_proofs::plonk::ConstraintSystem<Fr>) -> Self::Config {
        unreachable!("Use configure_with_params instead")
    }

    fn synthesize(
        &self,
        config: Self::Config,
        layouter: impl halo2_base::halo2_proofs::circuit::Layouter<Fr>,
    ) -> Result<(), halo2_base::halo2_proofs::plonk::Error> {
        self.builder.synthesize(config, layouter)
    }
}

impl CircuitExt<Fr> for DistrictCircuitForKeygen {
    fn num_instance(&self) -> Vec<usize> {
        vec![3] // ğŸ”’ CRITICAL: 3 public outputs (district_root, nullifier, action_id)
    }

    fn instances(&self) -> Vec<Vec<Fr>> {
        // ğŸ”’ CRITICAL FIX: Use public_outputs as source of truth, NOT builder.assigned_instances
        //
        // WHY: When gen_evm_verifier_shplonk() processes the circuit during keygen, it may
        // call this instances() method multiple times. The builder.assigned_instances might
        // be in different states depending on when synthesis happens.
        //
        // The public_outputs field stores the EXACT values we want as public inputs,
        // and they're immutably bound to this wrapper instance.
        //
        // This ensures num_instance() and instances() are ALWAYS consistent:
        // - num_instance() returns vec![3] (1 column with 3 values)
        // - instances() returns vec![vec![v0, v1, v2]] (1 column with 3 values)
        vec![self.public_outputs.iter().map(|v| *v.value()).collect()]
    }
}

/// Load ceremony parameters (mirrors prover.rs logic)
fn load_ceremony_params_for_verifier(k: u32) -> Result<ParamsKZG<Bn256>, String> {
    use std::io::Read as _;

    let params_dir = Path::new("./kzg_params");
    // ğŸ”’ CRITICAL: Use Axiom challenge_0085 params for snark-verifier compatibility
    let ceremony_path = params_dir.join(format!("axiom_params_k{}.srs", k));

    // SECURITY: Production mode only - no test params allowed for verifier generation
    if !ceremony_path.exists() {
        return Err(format!(
            "ğŸš¨ SECURITY ERROR: KZG ceremony parameters not found\n\
             \n\
             Required file: {}\n\
             \n\
             Verifier generation REQUIRES Axiom challenge_0085 ceremony parameters.\n\
             Test parameters are NOT allowed for verifier generation.\n\
             \n\
             Download ceremony parameters from Axiom's canonical source:\n\
             wget https://axiom-crypto.s3.amazonaws.com/challenge_0085/kzg_bn254_{}.srs \\\n\
                  -O ./kzg_params/axiom_params_k{}.srs\n\
             ",
            ceremony_path.display(),
            k,
            k
        ));
    }

    eprintln!("ğŸ” Loading Ethereum ceremony parameters from {}...", ceremony_path.display());

    let mut file = fs::File::open(&ceremony_path)
        .map_err(|e| format!("Failed to open ceremony params: {}", e))?;

    let mut buffer = Vec::new();
    file.read_to_end(&mut buffer)
        .map_err(|e| format!("Failed to read ceremony params: {}", e))?;

    // ğŸ”’ SECURITY: Verify integrity with Blake2b hash (defense against supply-chain attacks)
    use blake2::{Blake2b512, Digest};
    let hash = Blake2b512::digest(&buffer);
    let hash_hex = format!("{:x}", hash);

    // ğŸ” CANONICAL HASHES: Axiom challenge_0085 ceremony (snark-verifier compatible)
    // These hashes are IMMUTABLE. Any mismatch = potential attack vector.
    const CANONICAL_HASH_K12: &str = "PLACEHOLDER_K12"; // TODO: Record actual K=12 hash
    const CANONICAL_HASH_K14: &str = "PLACEHOLDER_WILL_BE_COMPUTED"; // Will be computed on first run

    eprintln!("ğŸ“Š Parameter file hash: {}", &hash_hex[..16]);

    // Verify hash based on K value
    match k {
        12 => {
            // ğŸš¨ TODO: Update with actual K=12 canonical hash from Ethereum ceremony
            // For now, log hash for manual verification
            eprintln!("âš ï¸  K=12 hash verification: Canonical hash not yet recorded");
            eprintln!("   Computed hash: {}", hash_hex);
            eprintln!("   ACTION REQUIRED: Verify this matches Ethereum ceremony K=12 hash");
            eprintln!("   Source: https://trusted-setup-holesky.s3.amazonaws.com/");
            // Uncomment after recording canonical hash:
            // if hash_hex != CANONICAL_HASH_K12 {
            //     return Err(format!("ğŸš¨ K=12 parameter hash mismatch: {}", hash_hex));
            // }
        }
        14 => {
            if CANONICAL_HASH_K14 == "PLACEHOLDER_WILL_BE_COMPUTED" {
                eprintln!("âš ï¸  FIRST RUN: Recording Blake2b-512 hash for Axiom challenge_0085 k=14 params");
                eprintln!("   Computed hash: {}", hash_hex);
                eprintln!("   ğŸ“‹ ACTION REQUIRED: Update CANONICAL_HASH_K14 in generate_verifier.rs");
            } else if hash_hex != CANONICAL_HASH_K14 {
                return Err(format!("ğŸš¨ K=14 parameter hash mismatch: Expected {}, got {}", CANONICAL_HASH_K14, hash_hex));
            } else {
                eprintln!("âœ… Hash verification PASSED - Parameters are Axiom challenge_0085 canonical");
            }
        }
        _ => {
            eprintln!("âš ï¸  No canonical hash recorded for K={}, skipping verification", k);
            eprintln!("   Computed hash: {}", hash_hex);
        }
    }

    // Load and deserialize parameters using read_custom
    let params = ParamsKZG::<Bn256>::read_custom(&mut buffer.as_slice(), halo2_base::halo2_proofs::SerdeFormat::RawBytesUnchecked)
        .map_err(|e| format!("Failed to deserialize ceremony params: {}", e))?;

    eprintln!("âœ… Loaded Axiom challenge_0085 ceremony parameters (k={})", k);

    Ok(params)
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("ğŸ”§ Generating EVM verifier for district membership circuit...");
    println!();

    // 1. Load KZG ceremony parameters (same as prover)
    println!("ğŸ“¦ Loading KZG ceremony parameters (k={})...", K);

    let params = load_ceremony_params_for_verifier(K)?;
    println!("âœ… Loaded ceremony parameters ({} elements)", params.n());
    println!();

    // 2. Create circuit for keygen (determines shape)
    println!("ğŸ—ï¸  Building circuit for keygen...");
    let mut builder = RangeCircuitBuilder::from_stage(CircuitBuilderStage::Keygen).use_k(K as usize);
    builder.set_lookup_bits(8);
    builder.set_instance_columns(1); // 3 public outputs in 1 column

    // ğŸ”’ SECURITY: Create dummy circuit with SINGLE-TIER structure
    // Shape MUST match production prover exactly
    let dummy_circuit = DistrictMembershipCircuit {
        identity_commitment: Fr::zero(),
        leaf_index: 0,
        merkle_path: vec![Fr::zero(); 12], // 12 levels for district tree
        action_id: Fr::zero(),
    };

    // Run circuit to populate builder (keygen stage)
    let range = builder.range_chip();
    let gate = range.gate();
    let ctx = builder.main(0);

    // Single-tier circuit returns 3 outputs
    let (district_root, nullifier, action_id_out) =
        dummy_circuit.verify_membership(ctx, gate);

    // Add to instance column
    builder.assigned_instances.clear();
    builder.assigned_instances.push(vec![
        district_root,
        nullifier,
        action_id_out,
    ]);

    let public_outputs = vec![
        district_root,
        nullifier,
        action_id_out,
    ];

    println!("âœ… Circuit configured:");
    println!("   - K: {} (16,384 rows)", K);
    println!("   - Lookup bits: 8");
    println!("   - Instance columns: 1");
    println!("   - Public outputs: 3 (district_root, nullifier, action_id)");
    println!();

    // Calculate circuit parameters
    let config_params = builder.calculate_params(Some(9));

    println!("ğŸ“Š Circuit parameters calculated:");
    println!("   - Advice columns: {}", config_params.num_advice_per_phase[0]);
    println!("   - Fixed columns: {}", config_params.num_fixed);
    println!("   - Lookup advice: {:?}", config_params.num_lookup_advice_per_phase);
    println!("   - ğŸš¨ CRITICAL: Bytecode size ~ O(num_columns), not O(num_rows)");
    println!();

    // 3. Wrap circuit for keygen (MUST use same wrapper for keygen and proving)
    // ğŸ”’ CRITICAL: This wrapper MUST be used for BOTH keygen AND proving
    println!("\nğŸ” P0 DIAGNOSTIC: Instance Structure Check");
    println!("   builder.assigned_instances.len(): {}", builder.assigned_instances.len());
    for (i, col) in builder.assigned_instances.iter().enumerate() {
        println!("   Column {}: {} values", i, col.len());
    }

    let circuit_for_keygen = DistrictCircuitForKeygen {
        builder: builder.clone(),
        public_outputs: vec![district_root, nullifier, action_id_out],
    };

    println!("   circuit_for_keygen.num_instance(): {:?}", circuit_for_keygen.num_instance());
    println!("   circuit_for_keygen.instances().len(): {}", circuit_for_keygen.instances().len());
    for (i, col) in circuit_for_keygen.instances().iter().enumerate() {
        println!("   Instance column {}: {} values", i, col.len());
    }

    println!("\nâš ï¸  CRITICAL CHECK:");
    if circuit_for_keygen.num_instance().len() != circuit_for_keygen.instances().len() {
        println!("   âŒ MISMATCH DETECTED!");
        println!("   num_instance() says {} columns", circuit_for_keygen.num_instance().len());
        println!("   instances() returns {} columns", circuit_for_keygen.instances().len());
        println!("   THIS IS THE BUG - verifier expects different structure than prover provides");
    } else {
        println!("   âœ… Column count matches");
    }
    println!();

    // 4. Generate proving key (which contains verifying key)
    // ğŸ”’ CRITICAL: This PK will be used for ALL proof generation
    // The verifier MUST use the VK from this PK, not a separately generated VK
    println!("ğŸ”‘ Generating proving key with wrapped circuit (this takes ~30-60 seconds)...");
    println!("   This key will be saved and used for all future proof generation");

    // First generate VK using WRAPPED circuit
    let vk = keygen_vk(&params, &circuit_for_keygen)
        .map_err(|e| format!("Failed to generate verifying key: {:?}", e))?;

    // Then generate PK from VK using WRAPPED circuit
    let pk = keygen_pk(&params, vk, &circuit_for_keygen)
        .map_err(|e| format!("Failed to generate proving key: {:?}", e))?;

    println!("âœ… Proving key generated");
    println!();

    // ğŸ”’ Extract break_points from the circuit_for_keygen's builder
    // After keygen, the builder inside the wrapped circuit has break_points set
    println!("ğŸ“Š Extracting break points from wrapped circuit's builder...");
    let break_points = circuit_for_keygen.builder.break_points();
    println!("âœ… Break points extracted ({} phases)", break_points.len());
    println!();

    // Save PK to disk for prover to load
    println!("ğŸ’¾ Saving proving key to disk...");
    let pk_path = Path::new("./kzg_params/pk_k14.bin");
    fs::create_dir_all("./kzg_params")?;

    let mut pk_file = fs::File::create(pk_path)
        .map_err(|e| format!("Failed to create PK file: {}", e))?;

    pk.write(&mut pk_file, halo2_base::halo2_proofs::SerdeFormat::RawBytesUnchecked)
        .map_err(|e| format!("Failed to write PK to disk: {}", e))?;

    println!("âœ… Proving key saved to: {}", pk_path.display());

    // Save break points alongside PK (required for prover)
    let break_points_path = Path::new("./kzg_params/pk_k14_break_points.json");
    let break_points_json = serde_json::to_string_pretty(&break_points)?;
    fs::write(&break_points_path, break_points_json)?;

    println!("âœ… Break points saved to: {}", break_points_path.display());
    println!();

    // 5. Generate EVM verifier using VK from the proving key
    // ğŸ”’ CRITICAL: We MUST use pk.get_vk() here, not a separately generated VK
    // This ensures the verifier's VK matches the PK used for proving
    // Also MUST use the SAME wrapped circuit (circuit_for_keygen) for consistency
    println!("âš™ï¸  Generating EVM verifier bytecode from proving key...");

    use snark_verifier_sdk::evm::gen_evm_verifier_shplonk;

    // Prepare output paths
    let output_dir = Path::new("../../../contracts/src");
    fs::create_dir_all(output_dir)?;

    // Generate bytecode using VK from the PK we just generated
    // âœ… Using same circuit_for_keygen that was used for PK generation
    let deployment_code = gen_evm_verifier_shplonk::<DistrictCircuitForKeygen>(
        &params,
        pk.get_vk(), // Use VK from proving key (Axiom pattern)
        circuit_for_keygen.num_instance(),
        None, // Skip Solidity generation - we only need bytecode
    );

    println!("âœ… Verifier bytecode generated ({} bytes)", deployment_code.len());
    println!();

    // 6. Compute verifying key hash for audit trail
    let vk_hash = compute_vk_hash(pk.get_vk())?;

    // 7. Write deployment information
    // Write bytecode to file
    let bytecode_path = output_dir.join("Halo2Verifier.bytecode");
    fs::write(&bytecode_path, &deployment_code)?;
    println!("ğŸ’¾ Written unoptimized bytecode to: {}", bytecode_path.display());

    // Write deployment info
    let info_path = output_dir.join("Halo2Verifier.deployment.md");
    let info_content = format!(
        r#"# Halo2Verifier Deployment Information

**Generation Date**: {}
**Circuit**: District Membership (Single-Tier K=14)
**K**: {}
**Public Outputs**: 3 (district_root, nullifier, action_id)
**Commitment Scheme**: SHPLONK + KZG on BN256
**Verifying Key Hash**: {}

## Architecture (2025-10-28)

**Current**: Single-tier K=14 (~12-16KB verifier, 8-15s mobile proving)
**Security model**: ZK proof + on-chain DistrictRegistry.sol
**Advantage**: Fits EIP-170 limit, deployable to any EVM chain

## Bytecode

**File**: `Halo2Verifier.bytecode`
**Size**: {} bytes
**Format**: EVM deployment bytecode
**EIP-170 limit**: 24,576 bytes (24KB)

## Deployment

This bytecode can be deployed directly to Ethereum/Scroll:

```bash
# Using cast (Foundry)
cast send --create $(cat contracts/src/Halo2Verifier.bytecode)

# Or deploy via Solidity wrapper (recommended)
# See contracts/src/Halo2VerifierWrapper.sol
```

## Integration

The deployed verifier contract expects:
- **Function signature**: `function verify(bytes calldata proof, uint256[3] calldata publicInputs) external view returns (bool)`
- **Public inputs order**: [district_root, nullifier, action_id]
- **Proof format**: SHPLONK proof bytes (384-512 bytes)

### Two-Step Verification Flow

```solidity
// Step 1: Verify ZK proof (district membership + nullifier)
bool valid = halo2Verifier.verify(proof, [districtRoot, nullifier, actionId]);

// Step 2: Verify districtâ†’country mapping (on-chain registry)
bytes3 country = districtRegistry.getCountry(districtRoot);
require(country == expectedCountry, "Unauthorized district");
```

## Gas Costs

Expected verification gas cost: **300-400k gas**

This includes:
- BN256 pairing operations (~250k gas)
- Polynomial commitment opening verification (SHPLONK)
- Public input validation (3 field elements)
- Fewer columns than two-tier (6-8 vs 12) reduces commitment overhead

On-chain registry lookup adds ~2.1k gas (SLOAD operation)

## Security

**Verifying Key Hash**: {}

This hash identifies the exact circuit configuration. Any change to:
- Circuit structure
- Public output count/order
- KZG parameters
- Commitment scheme

...will produce a different verifying key hash.

**Audit Status**:
- halo2-lib: Trail of Bits audited (2023-08-15)
- snark-verifier: Trail of Bits audited (2024-06-05)
- Circuit: Internal Brutalist audit complete (2025-10-26)
- External audit: Pending (Week 4-6)

## Regeneration

To regenerate this verifier:

```bash
cd packages/crypto/circuits
cargo run --bin generate_verifier --release
```

**WARNING**: Only regenerate if circuit structure changes. Changing the verifier
requires redeploying contracts and updating all integration points.
"#,
        chrono::Utc::now().format("%Y-%m-%d %H:%M UTC"),
        K,
        vk_hash,
        deployment_code.len(),
        vk_hash
    );

    fs::write(&info_path, info_content)?;
    println!("ğŸ“ Written deployment info to: {}", info_path.display());
    println!();

    // 8. Success summary
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println!("âœ… VERIFIER GENERATION COMPLETE");
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println!();
    println!("Generated files:");
    println!("  Bytecode: {} ({} bytes)", bytecode_path.display(), deployment_code.len());
    println!("  Info:     {}", info_path.display());
    println!();
    println!("Circuit:");
    println!("  Type:     District membership (Single-tier K=14)");
    println!("  K:        {} (16,384 rows)", K);
    println!("  Outputs:  3 (district_root, nullifier, action_id)");
    println!("  Scheme:   SHPLONK + KZG on BN256");
    println!("  VK Hash:  {}", vk_hash);
    println!();

    // Check bytecode size and warn if over EIP-170 limit
    let eip170_limit = 24576;
    if deployment_code.len() > eip170_limit {
        let overage = deployment_code.len() - eip170_limit;
        let overage_pct = (overage as f64 / eip170_limit as f64) * 100.0;
        println!("âš ï¸  BYTECODE SIZE WARNING:");
        println!("  Generated bytecode: {} bytes", deployment_code.len());
        println!("  EIP-170 limit:      {} bytes", eip170_limit);
        println!("  Overage:            {} bytes ({:.1}%)", overage, overage_pct);
        println!();
        println!("  ACTION: Optimize with Solidity compiler:");
        println!("     cd contracts/src");
        println!("     solc --optimize --optimize-runs 1 --bin Halo2Verifier.sol > Halo2Verifier.optimized.bytecode");
        println!();
    } else {
        let margin = eip170_limit - deployment_code.len();
        let margin_pct = (margin as f64 / eip170_limit as f64) * 100.0;
        println!("âœ… BYTECODE SIZE:");
        println!("  Generated bytecode: {} bytes", deployment_code.len());
        println!("  EIP-170 limit:      {} bytes", eip170_limit);
        println!("  Margin:             {} bytes ({:.1}% under limit)", margin, margin_pct);
        println!();
        println!("  âœ… Fits EIP-170 limit - can deploy directly to Ethereum/Scroll");
        println!();
    }

    println!("âš ï¸  NEXT STEPS:");
    println!("  1. Test circuit with MockProver (verify constraints):");
    println!("     cargo test --lib test_district_membership_single_tier");
    println!();
    println!("  2. Deploy to Scroll Sepolia testnet:");
    println!("     cd contracts");
    println!("     forge script script/DeployVerifier.s.sol --rpc-url scroll_sepolia --broadcast");
    println!();
    println!("  3. Test with real proofs from Rust prover:");
    println!("     cargo test --lib test_end_to_end_proof");
    println!();
    println!("  4. Measure actual gas costs (expect 200-300k for verification)");
    println!();
    println!("  5. Update DistrictGate.sol to use deployed verifier");
    println!();
    println!("ğŸ”’ SECURITY: This verifier will verify ALL district proofs on-chain.");
    println!("   Professional audit REQUIRED before mainnet.");
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");

    Ok(())
}

/// Compute verifying key hash for audit trail
fn compute_vk_hash(vk: &halo2_base::halo2_proofs::plonk::VerifyingKey<G1Affine>) -> Result<String, Box<dyn std::error::Error>> {
    use blake2::{Blake2b512, Digest};

    // Serialize verifying key to bytes using Debug representation
    // Note: In production, should use canonical serialization
    let hash_input = format!("{:?}", vk);
    let hash = Blake2b512::digest(hash_input.as_bytes());

    // Take first 16 hex characters for compact representation
    Ok(format!("{:x}", hash)[..16].to_string())
}
