name: Shadow Atlas Quarterly Update

on:
  schedule:
    # Quarterly: 1st day of Jan, Apr, Jul, Oct at 2 AM UTC
    - cron: '0 2 1 1,4,7,10 *'
  workflow_dispatch:
    inputs:
      publish_ipfs:
        description: 'Publish to IPFS'
        required: false
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'
      update_registry:
        description: 'Update on-chain registry'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

jobs:
  extract-tiger:
    name: Extract TIGER Data
    runs-on: ubuntu-latest
    timeout-minutes: 120
    outputs:
      extraction_summary: ${{ steps.extract.outputs.summary }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: packages/crypto/package-lock.json

      - name: Install dependencies
        working-directory: packages/crypto
        run: npm ci

      - name: Extract TIGER data for all 50 states
        id: extract
        working-directory: packages/crypto
        run: |
          # Create extraction directory
          mkdir -p .shadow-atlas/tiger-quarterly

          # Extract all states
          npx tsx services/shadow-atlas/scripts/multi-state-validation.ts

          # Generate summary
          SUMMARY=$(cat multi-state-validation-report.json | jq -c '{
            totalStates: .totalStates,
            totalTests: .totalTests,
            passed: .summary.passed,
            failed: (.totalTests - .summary.passed),
            timestamp: .timestamp
          }')

          echo "summary=$SUMMARY" >> $GITHUB_OUTPUT

          # Move extraction report
          mv multi-state-validation-report.json .shadow-atlas/tiger-quarterly/

          echo "✅ TIGER extraction complete"

      - name: Upload extraction data
        uses: actions/upload-artifact@v4
        with:
          name: tiger-extraction
          path: packages/crypto/.shadow-atlas/tiger-quarterly/
          retention-days: 90

  validate-extraction:
    name: Validate Extraction
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [extract-tiger]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: packages/crypto/package-lock.json

      - name: Install dependencies
        working-directory: packages/crypto
        run: npm ci

      - name: Download extraction data
        uses: actions/download-artifact@v4
        with:
          name: tiger-extraction
          path: packages/crypto/.shadow-atlas/tiger-quarterly/

      - name: Validate all 50 states
        working-directory: packages/crypto
        run: |
          # Run comprehensive validation
          REPORT=".shadow-atlas/tiger-quarterly/multi-state-validation-report.json"

          if [ ! -f "$REPORT" ]; then
            echo "❌ Extraction report not found"
            exit 1
          fi

          # Check validation results
          TOTAL_TESTS=$(cat $REPORT | jq -r '.totalTests')
          PASSED=$(cat $REPORT | jq -r '.summary.passed')
          FAILED=$(($TOTAL_TESTS - $PASSED))

          echo "Total tests: $TOTAL_TESTS"
          echo "Passed: $PASSED"
          echo "Failed: $FAILED"

          # Require 95% pass rate
          PASS_RATE=$(echo "scale=2; $PASSED / $TOTAL_TESTS * 100" | bc)
          echo "Pass rate: $PASS_RATE%"

          if (( $(echo "$PASS_RATE < 95.0" | bc -l) )); then
            echo "❌ Validation pass rate below 95% threshold: $PASS_RATE%"
            exit 1
          fi

          echo "✅ Validation passed with $PASS_RATE% pass rate"

      - name: Check for data quality issues
        working-directory: packages/crypto
        run: |
          REPORT=".shadow-atlas/tiger-quarterly/multi-state-validation-report.json"

          # Check for critical errors
          ERRORS=$(cat $REPORT | jq -r '.summary.errors')

          if [ "$ERRORS" -gt 0 ]; then
            echo "⚠️  $ERRORS errors detected in extraction"
            cat $REPORT | jq '.stateResults[] | select(.status == "error")'
          fi

          # Check for missing states
          TOTAL_STATES=$(cat $REPORT | jq -r '.totalStates')

          if [ "$TOTAL_STATES" -lt 50 ]; then
            echo "❌ Missing states: expected 50, got $TOTAL_STATES"
            exit 1
          fi

          echo "✅ All 50 states present"

  build-merkle:
    name: Build Merkle Tree
    runs-on: ubuntu-latest
    timeout-minutes: 60
    needs: [validate-extraction]
    outputs:
      ipfs_cid: ${{ steps.merkle.outputs.ipfs_cid }}
      root_hash: ${{ steps.merkle.outputs.root_hash }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: packages/crypto/package-lock.json

      - name: Install dependencies
        working-directory: packages/crypto
        run: npm ci

      - name: Download extraction data
        uses: actions/download-artifact@v4
        with:
          name: tiger-extraction
          path: packages/crypto/.shadow-atlas/tiger-quarterly/

      - name: Build Merkle tree
        id: merkle
        working-directory: packages/crypto
        run: |
          # Build Merkle tree from TIGER data
          # This should invoke the merkle-tree-builder service

          # Placeholder - replace with actual Merkle tree builder script
          echo "Building Merkle tree from TIGER data..."

          # Generate mock CID and root hash for workflow
          IPFS_CID="Qm$(openssl rand -hex 23)"
          ROOT_HASH="0x$(openssl rand -hex 32)"

          echo "ipfs_cid=$IPFS_CID" >> $GITHUB_OUTPUT
          echo "root_hash=$ROOT_HASH" >> $GITHUB_OUTPUT

          echo "Merkle tree built:"
          echo "  IPFS CID: $IPFS_CID"
          echo "  Root Hash: $ROOT_HASH"

      - name: Generate Merkle proofs
        working-directory: packages/crypto
        run: |
          # Generate sample proofs for testing
          echo "Generating Merkle proofs..."

          # Placeholder - replace with actual proof generation
          mkdir -p .shadow-atlas/tiger-quarterly/proofs

          echo "✅ Merkle proofs generated"

      - name: Upload Merkle artifacts
        uses: actions/upload-artifact@v4
        with:
          name: merkle-tree
          path: packages/crypto/.shadow-atlas/tiger-quarterly/
          retention-days: 180

  publish-ipfs:
    name: Publish to IPFS
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [build-merkle]
    if: github.event.inputs.publish_ipfs != 'false'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Merkle artifacts
        uses: actions/download-artifact@v4
        with:
          name: merkle-tree
          path: packages/crypto/.shadow-atlas/tiger-quarterly/

      - name: Setup IPFS
        uses: ibnesayeed/setup-ipfs@master
        with:
          ipfs_version: '^0.24'

      - name: Publish to IPFS
        id: ipfs
        run: |
          # Start IPFS daemon
          ipfs daemon &
          IPFS_PID=$!
          sleep 10

          # Add directory to IPFS
          CID=$(ipfs add -r packages/crypto/.shadow-atlas/tiger-quarterly/ | tail -n 1 | awk '{print $2}')

          echo "IPFS CID: $CID"
          echo "cid=$CID" >> $GITHUB_OUTPUT

          # Pin to Pinata (optional - requires API key)
          if [ -n "${{ secrets.PINATA_API_KEY }}" ]; then
            curl -X POST "https://api.pinata.cloud/pinning/pinByHash" \
              -H "Content-Type: application/json" \
              -H "pinata_api_key: ${{ secrets.PINATA_API_KEY }}" \
              -H "pinata_secret_api_key: ${{ secrets.PINATA_SECRET_KEY }}" \
              -d "{\"hashToPin\":\"$CID\"}"

            echo "✅ Pinned to Pinata"
          fi

          # Stop IPFS daemon
          kill $IPFS_PID

      - name: Create IPFS gateway links
        run: |
          CID="${{ steps.ipfs.outputs.cid }}"

          echo "IPFS Gateway Links:" >> $GITHUB_STEP_SUMMARY
          echo "- https://ipfs.io/ipfs/$CID" >> $GITHUB_STEP_SUMMARY
          echo "- https://cloudflare-ipfs.com/ipfs/$CID" >> $GITHUB_STEP_SUMMARY
          echo "- https://gateway.pinata.cloud/ipfs/$CID" >> $GITHUB_STEP_SUMMARY

  update-registry:
    name: Update On-Chain Registry
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [publish-ipfs]
    if: github.event.inputs.update_registry == 'true'
    environment:
      name: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: packages/crypto/package-lock.json

      - name: Install dependencies
        working-directory: packages/crypto
        run: npm ci

      - name: Update on-chain registry
        working-directory: packages/crypto
        env:
          PRIVATE_KEY: ${{ secrets.DEPLOYER_PRIVATE_KEY }}
          RPC_URL: ${{ secrets.SCROLL_RPC_URL }}
          IPFS_CID: ${{ needs.build-merkle.outputs.ipfs_cid }}
          ROOT_HASH: ${{ needs.build-merkle.outputs.root_hash }}
        run: |
          # Update on-chain registry with new IPFS CID and Merkle root
          # This should invoke a smart contract interaction script

          echo "Updating on-chain registry..."
          echo "  IPFS CID: $IPFS_CID"
          echo "  Root Hash: $ROOT_HASH"

          # Placeholder - replace with actual contract interaction
          # npx hardhat run scripts/update-registry.ts --network scroll

          echo "✅ On-chain registry updated"

      - name: Verify on-chain update
        run: |
          echo "Verifying on-chain update..."

          # Placeholder - replace with actual verification
          # npx hardhat run scripts/verify-registry.ts --network scroll

          echo "✅ On-chain update verified"

  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [extract-tiger, validate-extraction, build-merkle, publish-ipfs, update-registry]
    if: always()
    steps:
      - name: Create GitHub Issue with results
        uses: actions/github-script@v7
        with:
          script: |
            const extractionSummary = JSON.parse('${{ needs.extract-tiger.outputs.extraction_summary }}');

            const title = `Shadow Atlas Quarterly Update - ${extractionSummary.timestamp}`;
            const body = `
            ## Quarterly TIGER Data Update

            **Date:** ${extractionSummary.timestamp}

            ### Extraction Results
            - **Total States:** ${extractionSummary.totalStates}
            - **Total Tests:** ${extractionSummary.totalTests}
            - **Passed:** ${extractionSummary.passed}
            - **Failed:** ${extractionSummary.failed}
            - **Pass Rate:** ${(extractionSummary.passed / extractionSummary.totalTests * 100).toFixed(1)}%

            ### Job Results
            | Job | Status |
            |-----|--------|
            | Extract TIGER | ${{ needs.extract-tiger.result }} |
            | Validate Extraction | ${{ needs.validate-extraction.result }} |
            | Build Merkle | ${{ needs.build-merkle.result }} |
            | Publish IPFS | ${{ needs.publish-ipfs.result }} |
            | Update Registry | ${{ needs.update-registry.result }} |

            ### IPFS Information
            - **CID:** ${{ needs.build-merkle.outputs.ipfs_cid }}
            - **Root Hash:** ${{ needs.build-merkle.outputs.root_hash }}
            - **Gateway:** https://ipfs.io/ipfs/${{ needs.build-merkle.outputs.ipfs_cid }}

            ### Next Steps
            ${needs.update-registry.result === 'success'
              ? '✅ On-chain registry updated successfully'
              : '⚠️  Manual on-chain registry update required'}

            ---
            *This issue was automatically created by the quarterly update workflow.*
            `;

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['quarterly-update', 'shadow-atlas', 'automated']
            });

      - name: Notify Slack (optional)
        if: env.SLACK_WEBHOOK_URL != ''
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          SUMMARY='${{ needs.extract-tiger.outputs.extraction_summary }}'
          IPFS_CID='${{ needs.build-merkle.outputs.ipfs_cid }}'

          curl -X POST -H 'Content-type: application/json' \
            --data "{
              \"text\": \"Shadow Atlas Quarterly Update Complete\",
              \"blocks\": [
                {
                  \"type\": \"section\",
                  \"text\": {
                    \"type\": \"mrkdwn\",
                    \"text\": \"*Shadow Atlas Quarterly Update*\n\nNew IPFS CID: \`$IPFS_CID\`\n\nView details: ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}\"
                  }
                }
              ]
            }" \
            $SLACK_WEBHOOK_URL

  cleanup:
    name: Cleanup Artifacts
    runs-on: ubuntu-latest
    needs: [notify]
    if: always()
    steps:
      - name: Cleanup old artifacts
        uses: actions/github-script@v7
        with:
          script: |
            // Keep only last 4 quarterly updates (1 year)
            const artifactsResponse = await github.rest.actions.listArtifactsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100
            });

            const quarterlyArtifacts = artifactsResponse.data.artifacts
              .filter(a => a.name.startsWith('tiger-extraction') || a.name.startsWith('merkle-tree'))
              .sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

            // Keep first 4, delete rest
            for (let i = 4; i < quarterlyArtifacts.length; i++) {
              await github.rest.actions.deleteArtifact({
                owner: context.repo.owner,
                repo: context.repo.repo,
                artifact_id: quarterlyArtifacts[i].id
              });
              console.log(`Deleted artifact: ${quarterlyArtifacts[i].name}`);
            }
