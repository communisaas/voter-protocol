{
  "name": "Challenge Market Resolution - Optimized",
  "nodes": [
    {
      "parameters": {
        "type": "n8n-nodes-base.stickyNote",
        "info": "## Carroll Mechanisms: Challenge Market Resolution\n\n### Purpose\nImplements information quality markets where users stake VOTER tokens to challenge questionable claims, creating economic incentives for quality discourse.\n\n### Flow\n1. **Challenge Created**: Webhook receives challenge data\n2. **Data Preparation**: Validates challenge and calculates severity\n3. **Dual Verification**: Verifies both original claim and challenge\n4. **Consensus Check**: Routes to multi-agent consensus for critical challenges\n5. **Outcome Determination**: Determines winner based on evidence quality\n6. **Quadratic Payouts**: Distributes stakes with reputation-based scaling\n7. **Reputation Updates**: Updates challenger and creator reputation\n8. **Resolution Storage**: Persists challenge resolution to database\n\n### Key Features\n- üéØ **Quadratic Mechanisms**: Context-aware staking that scales with expertise, impact, and track record\n- ü§ñ **Multi-Agent Consensus**: Critical challenges get extra verification\n- üìä **Dynamic Severity**: Stake amounts determine verification intensity\n- ‚öñÔ∏è **Reputation Integration**: Track record affects staking requirements\n- üí∞ **Economic Incentives**: Winners earn stakes, losers lose them\n\n**Philosophy**: Quality discourse pays. Bad faith costs.",
        "height": 500,
        "width": 600
      },
      "id": "workflow-documentation",
      "name": "Workflow Documentation",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [100, 50]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "challenge-market",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "‚öîÔ∏è Challenge Created Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [200, 700],
      "webhookId": "challenge-market-trigger"
    },
    {
      "parameters": {
        "functionCode": "// Extract challenge data and validate with enhanced categorization\nconst challenge = $json;\n\n// Validate required fields\nconst requiredFields = ['challengerId', 'templateId', 'claimId', 'stakeAmount'];\nconst missingFields = requiredFields.filter(field => !challenge[field]);\n\nif (missingFields.length > 0) {\n  throw new Error(`Missing required challenge fields: ${missingFields.join(', ')}`);\n}\n\n// Enhanced challenge severity calculation based on multiple factors\nlet severity = 'low';\nconst stakeThreshold = parseFloat(challenge.stakeAmount);\nconst reputationDiff = Math.abs((challenge.challengerReputation || 0) - (challenge.creatorReputation || 0));\nconst templateUsage = challenge.templateUsageCount || 0;\n\n// Multi-factor severity calculation\nif (stakeThreshold > 50000 || templateUsage > 10000 || reputationDiff > 40) {\n  severity = 'critical';\n} else if (stakeThreshold > 10000 || templateUsage > 1000 || reputationDiff > 20) {\n  severity = 'high';\n} else if (stakeThreshold > 1000 || templateUsage > 100 || reputationDiff > 10) {\n  severity = 'medium';\n}\n\n// Generate deterministic challenge ID\nconst challengeId = challenge.challengeId || `chal_${challenge.claimId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n// Risk assessment\nconst riskFactors = {\n  highStake: stakeThreshold > 10000,\n  popularTemplate: templateUsage > 1000,\n  reputationGap: reputationDiff > 20,\n  firstTimeChallenger: (challenge.challengerReputation || 0) < 10\n};\n\nconst riskCount = Object.values(riskFactors).filter(Boolean).length;\nconst requiresConsensus = severity === 'critical' || riskCount >= 2;\n\nreturn {\n  json: {\n    challengeId,\n    challengerId: challenge.challengerId,\n    challengerAddress: challenge.challengerAddress,\n    templateId: challenge.templateId,\n    claimId: challenge.claimId,\n    claimText: challenge.claimText,\n    challengeReason: challenge.challengeReason,\n    stakeAmount: challenge.stakeAmount,\n    severity,\n    requiresConsensus,\n    createdAt: new Date().toISOString(),\n    metadata: {\n      challengerReputation: challenge.challengerReputation || 0,\n      creatorReputation: challenge.creatorReputation || 0,\n      templateUsageCount: templateUsage,\n      reputationDiff,\n      riskFactors,\n      riskScore: riskCount\n    }\n  }\n};"
      },
      "id": "prepare-challenge",
      "name": "‚öôÔ∏è Prepare Challenge Data",
      "type": "n8n-nodes-base.functionItem",
      "typeVersion": 1,
      "position": [400, 700]
    },
    {
      "parameters": {
        "workflowId": "agent-communication-subworkflow",
        "executionData": "={{JSON.stringify({agentType: 'verification', payload: {claimId: $json.claimId, claimText: $json.claimText, checkFactuality: true, checkSources: true, challengeContext: true}, timeout: 15000})}}"
      },
      "id": "verify-original-claim",
      "name": "üîç Verify Original Claim",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1,
      "position": [600, 600]
    },
    {
      "parameters": {
        "workflowId": "agent-communication-subworkflow",
        "executionData": "={{JSON.stringify({agentType: 'verification', payload: {claimId: $json.challengeId, claimText: $json.challengeReason, checkFactuality: true, checkSources: true, challengeContext: true}, timeout: 15000})}}"
      },
      "id": "verify-challenge-claim",
      "name": "üîç Verify Challenge Claim",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1,
      "position": [600, 800]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.requiresConsensus}}",
              "value2": true
            }
          ]
        }
      },
      "id": "check-consensus-needed",
      "name": "ü§ñ Consensus Needed?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [800, 700]
    },
    {
      "parameters": {
        "workflowId": "agent-communication-subworkflow",
        "executionData": "={{JSON.stringify({agentType: 'consensus', payload: {challengeId: $node['prepare-challenge'].json.challengeId, originalVerification: $node['verify-original-claim'].json, challengeVerification: $node['verify-challenge-claim'].json, stakeAmount: $node['prepare-challenge'].json.stakeAmount, severity: $node['prepare-challenge'].json.severity}, timeout: 30000})}}"
      },
      "id": "multi-agent-consensus",
      "name": "ü§ñ Multi-Agent Consensus",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1,
      "position": [1000, 650]
    },
    {
      "parameters": {
        "functionCode": "// Determine challenge outcome with enhanced scoring algorithm\nconst originalClaim = $node['verify-original-claim'].json;\nconst challengeClaim = $node['verify-challenge-claim'].json;\nconst challengeData = $node['prepare-challenge'].json;\nconst consensus = $node['multi-agent-consensus']?.json;\n\n// Use consensus if available, otherwise use direct comparison\nlet winner = 'original';\nlet confidence = 0.5;\nlet reasoning = 'Default outcome';\n\nif (consensus && consensus.success) {\n  // Multi-agent consensus available\n  winner = consensus.metrics.consensus === 'challenger' ? 'challenger' : 'original';\n  confidence = consensus.metrics.confidence;\n  reasoning = `Multi-agent consensus: ${consensus.metrics.reasoning || 'Consensus reached'}`;\n} else {\n  // Direct verification comparison\n  const originalConfidence = originalClaim.metrics?.confidence || 0;\n  const challengeConfidence = challengeClaim.metrics?.confidence || 0;\n  const confidenceDiff = challengeConfidence - originalConfidence;\n  \n  // Enhanced scoring with source quality and reputation factors\n  const originalSourceQuality = originalClaim.metrics?.sourceQuality || 0;\n  const challengeSourceQuality = challengeClaim.metrics?.sourceQuality || 0;\n  const sourceQualityDiff = challengeSourceQuality - originalSourceQuality;\n  \n  // Reputation factor (higher rep = slight bias towards their claims)\n  const repFactor = (challengeData.metadata.challengerReputation - challengeData.metadata.creatorReputation) * 0.01;\n  \n  // Combined score\n  const combinedScore = confidenceDiff + (sourceQualityDiff * 0.3) + repFactor;\n  \n  if (combinedScore > 0.15) {\n    winner = 'challenger';\n    confidence = challengeConfidence;\n    reasoning = 'Challenge provides superior evidence and sources';\n  } else if (combinedScore < -0.15) {\n    winner = 'original';\n    confidence = originalConfidence;\n    reasoning = 'Original claim has stronger foundation';\n  } else {\n    // Very close - favor slightly based on source quality\n    if (sourceQualityDiff > 0.1) {\n      winner = 'challenger';\n      confidence = challengeConfidence;\n      reasoning = 'Challenge has significantly better source quality';\n    } else {\n      winner = 'original';\n      confidence = originalConfidence;\n      reasoning = 'Claims too close to determine clear winner - original stands';\n    }\n  }\n}\n\nreturn {\n  json: {\n    challengeId: challengeData.challengeId,\n    winner: winner,\n    confidence: confidence,\n    reasoning: reasoning,\n    originalScore: originalClaim.metrics?.confidence || 0,\n    challengeScore: challengeClaim.metrics?.confidence || 0,\n    consensusUsed: Boolean(consensus && consensus.success),\n    metadata: {\n      severity: challengeData.severity,\n      riskScore: challengeData.metadata.riskScore,\n      reputationDiff: challengeData.metadata.reputationDiff\n    }\n  }\n};"
      },
      "id": "determine-outcome",
      "name": "‚öñÔ∏è Determine Outcome",
      "type": "n8n-nodes-base.functionItem",
      "typeVersion": 1,
      "position": [1000, 800]
    },
    {
      "parameters": {
        "functionCode": "// Calculate quadratic stake redistribution with reputation scaling\nconst outcome = $json;\nconst challengeData = $node['prepare-challenge'].json;\nconst stakeAmount = parseFloat(challengeData.stakeAmount);\n\n// Get reputation scores\nconst challengerRep = challengeData.metadata.challengerReputation;\nconst creatorRep = challengeData.metadata.creatorReputation;\n\n// Base reputation changes (scaled by confidence)\nlet challengerRepChange = 0;\nlet creatorRepChange = 0;\n\n// Stake redistribution with quadratic scaling\nlet challengerPayout = 0;\nlet creatorPayout = 0;\nlet treasuryPayout = 0;\n\n// Quadratic scaling function - prevents whale dominance\nconst applyQuadraticScaling = (amount, reputation) => {\n  // Higher reputation = less scaling (more trusted)\n  const trustFactor = Math.min(1, reputation / 100);\n  const scaleFactor = Math.sqrt(1 - (0.5 * trustFactor));\n  return amount * scaleFactor;\n};\n\nif (outcome.winner === 'challenger') {\n  // Challenger wins - gets stake plus quadratic bonus\n  const baseReward = stakeAmount * 1.8; // 80% bonus\n  challengerPayout = applyQuadraticScaling(baseReward, challengerRep);\n  \n  // Reputation changes\n  challengerRepChange = Math.min(15, 5 + (outcome.confidence * 10));\n  creatorRepChange = -Math.min(10, 3 + (outcome.confidence * 7));\n  \n  treasuryPayout = stakeAmount * 0.1; // 10% to treasury\n  \n} else {\n  // Original creator wins - gets challenger's stake\n  const baseReward = stakeAmount * 1.3; // 30% bonus for defending truth\n  creatorPayout = applyQuadraticScaling(baseReward, creatorRep);\n  \n  // Reputation changes (less severe for failed challenges)\n  challengerRepChange = -Math.min(8, 2 + (outcome.confidence * 6));\n  creatorRepChange = Math.min(8, 2 + (outcome.confidence * 6));\n  \n  treasuryPayout = stakeAmount * 0.2; // 20% to treasury\n}\n\n// Apply consensus multiplier if multi-agent consensus was used\nif (outcome.consensusUsed) {\n  challengerRepChange *= 1.5;\n  creatorRepChange *= 1.5;\n  challengerPayout *= 1.1;\n  creatorPayout *= 1.1;\n}\n\n// Apply severity multiplier\nconst severityMultipliers = { low: 1, medium: 1.2, high: 1.5, critical: 2 };\nconst severityMultiplier = severityMultipliers[challengeData.severity] || 1;\n\nchallegerRepChange *= severityMultiplier;\ncreatorRepChange *= severityMultiplier;\n\nreturn {\n  json: {\n    challengeId: challengeData.challengeId,\n    winner: outcome.winner,\n    confidence: outcome.confidence,\n    reasoning: outcome.reasoning,\n    payouts: {\n      challenger: Math.round(challengerPayout),\n      creator: Math.round(creatorPayout),\n      treasury: Math.round(treasuryPayout)\n    },\n    reputationChanges: {\n      challenger: Math.round(challengerRepChange * 100) / 100,\n      creator: Math.round(creatorRepChange * 100) / 100\n    },\n    metadata: {\n      stakeAmount,\n      severity: challengeData.severity,\n      consensusUsed: outcome.consensusUsed,\n      quadraticScaling: true,\n      severityMultiplier\n    }\n  }\n};"
      },
      "id": "calculate-payouts",
      "name": "üí∞ Calculate Quadratic Payouts",
      "type": "n8n-nodes-base.functionItem",
      "typeVersion": 1,
      "position": [1200, 700]
    },
    {
      "parameters": {
        "workflowId": "agent-communication-subworkflow",
        "executionData": "={{JSON.stringify({agentType: 'reputation', payload: {challengerId: $node['prepare-challenge'].json.challengerId, creatorId: $node['prepare-challenge'].json.creatorId, reputationChanges: $json.reputationChanges, challengeContext: true}})}}"
      },
      "id": "update-reputation",
      "name": "‚≠ê Update Reputation",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1,
      "position": [1400, 800]
    },
    {
      "parameters": {
        "workflowId": "database-operations-subworkflow",
        "executionData": "={{JSON.stringify({operation: 'insert', table: 'challenge_resolutions', columns: {challenge_id: $json.challengeId, template_id: $node['prepare-challenge'].json.templateId, claim_id: $node['prepare-challenge'].json.claimId, challenger_address: $node['prepare-challenge'].json.challengerAddress, winner: $json.winner, confidence_score: $json.confidence, challenger_payout: $json.payouts.challenger, creator_payout: $json.payouts.creator, treasury_payout: $json.payouts.treasury, reasoning: $json.reasoning, severity: $json.metadata.severity, consensus_used: $json.metadata.consensusUsed, resolved_at: new Date().toISOString()}})}}"
      },
      "id": "store-resolution",
      "name": "üíæ Store Resolution",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1,
      "position": [1400, 700]
    },
    {
      "parameters": {
        "channel": "challenge-resolutions",
        "message": "=‚öñÔ∏è *Challenge Resolved*\\n\\n**Challenge ID:** `{{$json.challengeId}}`\\n**Winner:** {{$json.winner === 'challenger' ? 'ü•á Challenger' : 'üõ°Ô∏è Original Creator'}}\\n**Confidence:** {{($json.confidence * 100).toFixed(0)}}%\\n**Severity:** {{$json.metadata.severity}}\\n{{$json.metadata.consensusUsed ? 'ü§ñ Multi-agent consensus used' : ''}}\\n\\n**Reasoning:** {{$json.reasoning}}\\n\\n_Quality discourse pays. Bad faith costs._",
        "additionalFields": {
          "attachments": [
            {
              "color": "={{$json.winner === 'challenger' ? '#fbbf24' : '#34d399'}}",
              "title": "Resolution Details",
              "fields": {
                "values": [
                  {
                    "short": true,
                    "title": "Challenger Payout",
                    "value": "{{$json.payouts.challenger}} VOTER"
                  },
                  {
                    "short": true,
                    "title": "Creator Payout",
                    "value": "{{$json.payouts.creator}} VOTER"
                  },
                  {
                    "short": true,
                    "title": "Challenger Rep Œî",
                    "value": "={{$json.reputationChanges.challenger > 0 ? '+' : ''}}{{$json.reputationChanges.challenger}}"
                  },
                  {
                    "short": true,
                    "title": "Creator Rep Œî",
                    "value": "={{$json.reputationChanges.creator > 0 ? '+' : ''}}{{$json.reputationChanges.creator}}"
                  },
                  {
                    "short": true,
                    "title": "Treasury Fee",
                    "value": "{{$json.payouts.treasury}} VOTER"
                  },
                  {
                    "short": true,
                    "title": "Quadratic Scaling",
                    "value": "‚úÖ Applied"
                  }
                ]
              }
            }
          ],
          "thread_ts": "={{$json.challengeId}}"
        }
      },
      "id": "notify-resolution",
      "name": "üì¢ Notify Resolution",
      "type": "n8n-nodes-base.slack",
      "typeVersion": 2,
      "position": [1600, 750],
      "credentials": {
        "slackApi": {
          "id": "slack-notifications",
          "name": "Slack Notifications"
        }
      }
    },
    {
      "parameters": {
        "functionCode": "// Prepare final response with comprehensive challenge resolution data\nconst resolution = $json;\nconst reputationUpdate = $node['update-reputation']?.json;\nconst dbStorage = $node['store-resolution']?.json;\n\nreturn {\n  json: {\n    success: true,\n    challengeId: resolution.challengeId,\n    status: 'resolved',\n    winner: resolution.winner,\n    message: `Challenge resolved: ${resolution.winner} wins with ${(resolution.confidence * 100).toFixed(0)}% confidence`,\n    resolution: {\n      winner: resolution.winner,\n      confidence: resolution.confidence,\n      reasoning: resolution.reasoning,\n      severity: resolution.metadata.severity,\n      consensusUsed: resolution.metadata.consensusUsed\n    },\n    economics: {\n      payouts: resolution.payouts,\n      reputationChanges: resolution.reputationChanges,\n      quadraticScaling: resolution.metadata.quadraticScaling,\n      treasuryContribution: resolution.payouts.treasury\n    },\n    processing: {\n      stored: Boolean(dbStorage?.success),\n      reputationUpdated: Boolean(reputationUpdate?.success),\n      notificationSent: true\n    },\n    timestamp: new Date().toISOString(),\n    philosophy: 'Quality discourse pays. Bad faith costs.'\n  }\n};"
      },
      "id": "prepare-response",
      "name": "üìä Prepare Response",
      "type": "n8n-nodes-base.functionItem",
      "typeVersion": 1,
      "position": [1800, 700]
    },
    {
      "parameters": {},
      "id": "respond-to-webhook",
      "name": "üì§ Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [2000, 700]
    },
    {
      "parameters": {
        "type": "n8n-nodes-base.stickyNote",
        "info": "## Verification Phase\n\n**Parallel Verification:**\n- üîç Original claim verification\n- üîç Challenge claim verification\n\n**Dynamic Routing:**\n- ü§ñ Critical challenges ‚Üí Multi-agent consensus\n- üìä Standard challenges ‚Üí Direct comparison\n\n**Factors:**\n- Stake amount\n- Template usage\n- Reputation gap\n- Risk assessment",
        "height": 250,
        "width": 350
      },
      "id": "verification-phase-note",
      "name": "Verification Phase",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [550, 450]
    },
    {
      "parameters": {
        "type": "n8n-nodes-base.stickyNote",
        "info": "## Resolution Phase\n\n**Outcome Determination:**\n- Evidence quality comparison\n- Source credibility analysis\n- Reputation factor integration\n- Confidence scoring\n\n**Quadratic Economics:**\n- Reputation-based stake scaling\n- Anti-plutocracy mechanisms\n- Progressive reward distribution\n- Treasury fee collection",
        "height": 200,
        "width": 350
      },
      "id": "resolution-phase-note",
      "name": "Resolution Phase",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [1150, 450]
    },
    {
      "parameters": {
        "type": "n8n-nodes-base.stickyNote",
        "info": "## Finalization Phase\n\n**Updates:**\n- ‚≠ê Reputation scoring\n- üíæ Database persistence\n- üì¢ Community notifications\n\n**Economics:**\n- üí∞ Payout distribution\n- üèõÔ∏è Treasury contributions\n- üìà Reputation adjustments\n\n**Result:** Completed challenge with all stakeholders updated",
        "height": 200,
        "width": 350
      },
      "id": "finalization-phase-note",
      "name": "Finalization Phase",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [1550, 450]
    }
  ],
  "connections": {
    "‚öîÔ∏è Challenge Created Webhook": {
      "main": [
        [
          {
            "node": "‚öôÔ∏è Prepare Challenge Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "‚öôÔ∏è Prepare Challenge Data": {
      "main": [
        [
          {
            "node": "üîç Verify Original Claim",
            "type": "main",
            "index": 0
          },
          {
            "node": "üîç Verify Challenge Claim",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üîç Verify Original Claim": {
      "main": [
        [
          {
            "node": "ü§ñ Consensus Needed?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üîç Verify Challenge Claim": {
      "main": [
        [
          {
            "node": "ü§ñ Consensus Needed?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ü§ñ Consensus Needed?": {
      "main": [
        [
          {
            "node": "ü§ñ Multi-Agent Consensus",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "‚öñÔ∏è Determine Outcome",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ü§ñ Multi-Agent Consensus": {
      "main": [
        [
          {
            "node": "‚öñÔ∏è Determine Outcome",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "‚öñÔ∏è Determine Outcome": {
      "main": [
        [
          {
            "node": "üí∞ Calculate Quadratic Payouts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üí∞ Calculate Quadratic Payouts": {
      "main": [
        [
          {
            "node": "‚≠ê Update Reputation",
            "type": "main",
            "index": 0
          },
          {
            "node": "üíæ Store Resolution",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "‚≠ê Update Reputation": {
      "main": [
        [
          {
            "node": "üì¢ Notify Resolution",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üíæ Store Resolution": {
      "main": [
        [
          {
            "node": "üì¢ Notify Resolution",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üì¢ Notify Resolution": {
      "main": [
        [
          {
            "node": "üìä Prepare Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üìä Prepare Response": {
      "main": [
        [
          {
            "node": "üì§ Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": "global-error-handler"
  },
  "staticData": null,
  "tags": [
    {
      "name": "production",
      "createdAt": "2024-01-14T00:00:00.000Z"
    },
    {
      "name": "carroll-mechanisms",
      "createdAt": "2024-01-14T00:00:00.000Z"
    },
    {
      "name": "optimized",
      "createdAt": "2024-01-14T00:00:00.000Z"
    }
  ],
  "triggerCount": 1,
  "updatedAt": "2024-01-14T00:00:00.000Z",
  "createdAt": "2024-01-14T00:00:00.000Z",
  "id": "challenge-market-optimized",
  "meta": {
    "templateId": "challenge-market-resolution-v2",
    "description": "Optimized Carroll Mechanisms implementation with quadratic economics, multi-agent consensus, and comprehensive error handling"
  }
}