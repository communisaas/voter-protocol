// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import "forge-std/Test.sol";

/// @title Integration Test for Real Halo2 Proof Verification
/// @notice Tests the actual Halo2Verifier bytecode with a real proof generated from Rust circuit
/// @dev This is the critical integration test identified by the brutalist audit
///
/// SECURITY CONTEXT:
/// - Previous tests used MockHalo2Verifier (always returns true)
/// - This test uses REAL Halo2Verifier with REAL proof from circuit
/// - If this test passes, we know the verifier actually works with our circuit
/// - If this test fails, we cannot deploy (verifier might never verify real proofs)
///
/// TEST DATA SOURCE:
/// - Proof generated by: packages/crypto/circuits/src/prover.rs
/// - Test: export_proof_for_solidity_integration_test()
/// - Command: ALLOW_TEST_PARAMS=1 cargo test --lib --target aarch64-apple-darwin export_proof_for_solidity -- --ignored --nocapture
/// - Output: contracts/test/fixtures/proof_integration_test.json
///
/// PROOF DETAILS:
/// - Circuit size: k=14
/// - Proof size: 3328 bytes (single-tier K=14)
/// - Public inputs: 3 field elements (district_root, nullifier, action_id)
/// - Architecture: Single-tier circuit (districtâ†’country mapping on-chain)
/// - KZG params: Test parameters (NOT production ceremony params)
///
/// VERIFIER BYTECODE:
/// - Size: 20,143 bytes (fits EIP-170 24KB limit)
/// - Generated by: packages/crypto/circuits/bin/generate_verifier.rs
/// - Deployment: Raw EVM bytecode loaded from Halo2Verifier.bytecode
///
/// CRITICAL: This test uses TEST KZG parameters, not Ethereum ceremony params.
///          For production deployment, regenerate proof with ceremony params.
contract IntegrationTest is Test {
    address public verifier;

    // Test data loaded from JSON fixture
    // CRITICAL: Uses canonical calldata encoding from snark-verifier's encode_calldata
    // NOT manually constructed with abi.encodePacked
    struct ProofData {
        bytes calldataBytes;   // Pre-encoded calldata (instances + proof)
        bytes32 districtRoot;  // For display/logging only
        bytes32 nullifier;     // For display/logging only
        bytes32 actionId;      // For display/logging only
    }

    ProofData public testProof;

    function setUp() public {
        // Read proof JSON fixture
        string memory root = vm.projectRoot();
        string memory path = string.concat(root, "/test/fixtures/proof_integration_test.json");
        string memory json = vm.readFile(path);

        // Parse pre-encoded calldata (includes instances + proof with canonical encoding)
        // CRITICAL: This calldata is generated by snark-verifier's encode_calldata function
        // Do NOT manually construct with abi.encodePacked
        testProof.calldataBytes = vm.parseBytes(vm.parseJsonString(json, ".calldata"));

        // Parse public inputs for display/logging (NOT used in verification)
        testProof.districtRoot = bytes32(vm.parseBytes32(vm.parseJsonString(json, ".public_inputs.district_root")));
        testProof.nullifier = bytes32(vm.parseBytes32(vm.parseJsonString(json, ".public_inputs.nullifier")));
        testProof.actionId = bytes32(vm.parseBytes32(vm.parseJsonString(json, ".public_inputs.action_id")));

        // Deploy Halo2Verifier using raw bytecode (Forge cannot compile the 85KB Solidity source)
        // Circuit: Single-tier K=14 with 3 public outputs (district_root, nullifier, action_id)
        // Generated by: packages/crypto/circuits/bin/generate_verifier.rs
        // Note: We use raw bytecode because Forge miscompiles the massive assembly fallback
        string memory bytecodePath = string.concat(root, "/src/Halo2Verifier.bytecode");
        bytes memory bytecode = vm.readFileBinary(bytecodePath);

        address deployed;
        assembly {
            deployed := create(0, add(bytecode, 0x20), mload(bytecode))
        }

        verifier = deployed;
        require(verifier != address(0), "Verifier deployment failed");
    }

    /// @notice DEBUG: Check if verifier is deployed and has code
    function test_VerifierDeployed() public view {
        address verifierAddr = verifier;
        uint256 codeSize;
        assembly {
            codeSize := extcodesize(verifierAddr)
        }
        console.log("Verifier deployed at:", verifierAddr);
        console.log("Verifier code size:", codeSize);
        assertTrue(codeSize > 0, "Verifier should have code");
        assertTrue(codeSize > 10000, "Verifier code should be substantial");
    }

    /// @notice CRITICAL TEST: Verify real proof from circuit succeeds
    /// @dev If this test fails, the entire ZK system is broken
    function test_RealProofVerifies() public view {
        // Use pre-encoded calldata from snark-verifier's canonical encode_calldata
        // CRITICAL: Do NOT manually construct with abi.encodePacked
        // The Rust prover uses snark_verifier::loader::evm::encode_calldata which has
        // specific byte reversal logic that manual encoding doesn't replicate
        (bool success, bytes memory result) = address(verifier).staticcall(testProof.calldataBytes);

        // CRITICAL ASSERTION: Call must succeed
        assertTrue(success, "Verifier call should succeed");

        // Parse result (verifier returns boolean as bytes32)
        bool isValid = result.length > 0 && abi.decode(result, (uint256)) == 1;
        assertTrue(isValid, "Proof should verify");

        // Log success for visibility
        console.log("PASS: Real Halo2 proof verified successfully!");
        console.log("   Calldata size:", testProof.calldataBytes.length, "bytes");
        console.log("   District root:", vm.toString(testProof.districtRoot));
        console.log("   Nullifier:", vm.toString(testProof.nullifier));
        console.log("   Action ID:", vm.toString(testProof.actionId));
    }

    /// @notice Test that verification fails with wrong district root
    /// @dev This test manually constructs tampered calldata (intentionally wrong)
    function test_VerificationFailsWithWrongDistrictRoot() public view {
        // Extract the proof portion from calldata (after the 96-byte instance prefix)
        bytes memory proofOnly = new bytes(testProof.calldataBytes.length - 96);
        for (uint i = 0; i < proofOnly.length; i++) {
            proofOnly[i] = testProof.calldataBytes[i + 96];
        }

        // Manually construct tampered calldata with wrong district root
        bytes memory callData = abi.encodePacked(
            bytes32(uint256(12345)), // WRONG district root
            testProof.nullifier,
            testProof.actionId,
            proofOnly
        );

        (bool success, bytes memory result) = address(verifier).staticcall(callData);

        // Should either revert or return false
        bool isValid = success && result.length > 0 && abi.decode(result, (uint256)) == 1;
        assertFalse(isValid, "Proof with wrong district root should fail");
    }

    /// @notice Test that verification fails with wrong nullifier
    /// @dev This test manually constructs tampered calldata (intentionally wrong)
    function test_VerificationFailsWithWrongNullifier() public view {
        // Extract the proof portion from calldata (after the 96-byte instance prefix)
        bytes memory proofOnly = new bytes(testProof.calldataBytes.length - 96);
        for (uint i = 0; i < proofOnly.length; i++) {
            proofOnly[i] = testProof.calldataBytes[i + 96];
        }

        // Manually construct tampered calldata with wrong nullifier
        bytes memory callData = abi.encodePacked(
            testProof.districtRoot,
            bytes32(uint256(67890)), // WRONG nullifier
            testProof.actionId,
            proofOnly
        );

        (bool success, bytes memory result) = address(verifier).staticcall(callData);

        bool isValid = success && result.length > 0 && abi.decode(result, (uint256)) == 1;
        assertFalse(isValid, "Proof with wrong nullifier should fail");
    }

    /// @notice Test that verification fails with tampered proof bytes
    /// @dev This test manually tampers with the calldata (intentionally wrong)
    function test_VerificationFailsWithTamperedProof() public view {
        // Copy calldata and tamper with proof bytes (flip some bits in the middle)
        bytes memory tamperedCalldata = new bytes(testProof.calldataBytes.length);
        for (uint i = 0; i < testProof.calldataBytes.length; i++) {
            tamperedCalldata[i] = testProof.calldataBytes[i];
        }

        // Flip bits in the middle of the proof portion (after 96-byte instance prefix)
        uint256 proofStartIndex = 96;
        uint256 proofLength = testProof.calldataBytes.length - proofStartIndex;
        uint256 middleIndex = proofStartIndex + (proofLength / 2);
        tamperedCalldata[middleIndex] = bytes1(uint8(tamperedCalldata[middleIndex]) ^ 0xFF);

        (bool success, bytes memory result) = address(verifier).staticcall(tamperedCalldata);

        bool isValid = success && result.length > 0 && abi.decode(result, (uint256)) == 1;
        assertFalse(isValid, "Tampered proof should fail verification");
    }

    /// @notice Test that verification fails with wrong number of public inputs
    /// @dev This test manually constructs malformed calldata (intentionally wrong)
    function test_VerificationFailsWithWrongInputCount() public view {
        // Only provide 2 inputs (64 bytes instead of 96) - truncate calldata
        bytes memory malformedCalldata = new bytes(64);
        for (uint i = 0; i < 64; i++) {
            malformedCalldata[i] = testProof.calldataBytes[i];
        }

        // Should fail due to malformed calldata (missing action_id and proof)
        (bool success,) = address(verifier).staticcall(malformedCalldata);
        assertFalse(success, "Should fail with wrong input count");
    }

    /// @notice Measure gas cost of real proof verification
    /// @dev Important for understanding on-chain costs
    function test_VerificationGasCost() public view {
        // Use pre-encoded calldata (canonical encoding)
        uint256 gasBefore = gasleft();
        (bool success, bytes memory result) = address(verifier).staticcall(testProof.calldataBytes);
        uint256 gasUsed = gasBefore - gasleft();

        assertTrue(success, "Verifier call should succeed");
        bool isValid = result.length > 0 && abi.decode(result, (uint256)) == 1;
        assertTrue(isValid, "Proof should verify");
        console.log("Gas used for proof verification:", gasUsed);

        // Expected range: 300k-500k gas on Scroll zkEVM
        // This is much cheaper than generating the proof (~600ms-10s client-side)
        assertTrue(gasUsed > 100_000, "Gas cost suspiciously low");
        assertTrue(gasUsed < 1_000_000, "Gas cost suspiciously high");
    }
}
