// SPDX-License-Identifier: MIT
pragma solidity =0.8.19;

import "forge-std/Test.sol";
import "../src/DistrictGate.sol";
import "../src/Halo2Verifier.sol";

/// @title DistrictGateTest
/// @notice Comprehensive test suite for DistrictGate contract
/// @dev Tests cover:
///      - Valid proof verification
///      - Nullifier replay attack prevention
///      - Shadow Atlas root management
///      - Action authorization
///      - Batch verification
///      - Gas cost profiling
contract DistrictGateTest is Test {
    DistrictGate public gate;
    MockHalo2Verifier public verifier;

    // Test addresses
    address public owner = address(0x1);
    address public user1 = address(0x2);
    address public user2 = address(0x3);

    // Test data (BN254 field elements as bytes32)
    bytes32 public constant GLOBAL_ROOT = bytes32(uint256(0x123456));
    bytes32 public constant DISTRICT_ROOT_CA12 = bytes32(uint256(0xCA12));
    bytes32 public constant DISTRICT_ROOT_TX01 = bytes32(uint256(0x7E01));
    bytes32 public constant NULLIFIER_1 = bytes32(uint256(0xDEADBEEF));
    bytes32 public constant NULLIFIER_2 = bytes32(uint256(0xCAFEBABE));
    bytes32 public constant ACTION_ID_CONTACT = keccak256("contact_representative");

    // Mock proof bytes (placeholder)
    bytes public constant MOCK_PROOF = hex"deadbeef";

    function setUp() public {
        vm.startPrank(owner);

        // Deploy mock verifier (DEVELOPMENT ONLY)
        verifier = new MockHalo2Verifier();

        // Deploy DistrictGate with initial Shadow Atlas root
        gate = new DistrictGate(
            GLOBAL_ROOT,
            address(verifier)
        );

        // Authorize the contact_representative action
        gate.authorizeAction(ACTION_ID_CONTACT);

        vm.stopPrank();
    }

    // ============================================================================
    // Constructor Tests
    // ============================================================================

    function testConstructorSetsCorrectRoot() public {
        assertEq(gate.getShadowAtlasRoot(), GLOBAL_ROOT, "Shadow Atlas root mismatch");
    }

    function testConstructorSetsCorrectVerifier() public {
        assertEq(gate.getVerifierAddress(), address(verifier), "Verifier address mismatch");
    }

    function testConstructorRejectsZeroRoot() public {
        vm.expectRevert("Invalid initial root");
        new DistrictGate(bytes32(0), address(verifier));
    }

    function testConstructorRejectsZeroVerifier() public {
        vm.expectRevert("Invalid verifier address");
        new DistrictGate(GLOBAL_ROOT, address(0));
    }

    // ============================================================================
    // Valid Proof Verification Tests
    // ============================================================================

    function testVerifyValidProof() public {
        // Prepare public inputs
        bytes32[4] memory publicInputs = [
            GLOBAL_ROOT,         // global_root (matches current Shadow Atlas)
            DISTRICT_ROOT_CA12,  // district_root (CA-12)
            NULLIFIER_1,         // nullifier (unique)
            ACTION_ID_CONTACT    // action_id (authorized)
        ];

        // Verify proof as user1
        vm.prank(user1);
        bool result = gate.verifyDistrictMembership(MOCK_PROOF, publicInputs);

        assertTrue(result, "Proof verification should succeed");
        assertTrue(gate.isNullifierUsed(NULLIFIER_1), "Nullifier should be marked as used");
    }

    function testVerifyEmitsCorrectEvent() public {
        bytes32[4] memory publicInputs = [
            GLOBAL_ROOT,
            DISTRICT_ROOT_CA12,
            NULLIFIER_1,
            ACTION_ID_CONTACT
        ];

        // Verify proof emits event
        vm.prank(user1);
        gate.verifyDistrictMembership(MOCK_PROOF, publicInputs);
    }

    // ============================================================================
    // Nullifier Replay Attack Prevention Tests
    // ============================================================================

    function testRejectReusedNullifier() public {
        bytes32[4] memory publicInputs = [
            GLOBAL_ROOT,
            DISTRICT_ROOT_CA12,
            NULLIFIER_1,
            ACTION_ID_CONTACT
        ];

        // First verification succeeds
        vm.prank(user1);
        gate.verifyDistrictMembership(MOCK_PROOF, publicInputs);

        // Second verification with same nullifier should fail
        vm.prank(user1);
        vm.expectRevert(
            abi.encodeWithSelector(DistrictGate.NullifierAlreadyUsed.selector, NULLIFIER_1)
        );
        gate.verifyDistrictMembership(MOCK_PROOF, publicInputs);
    }

    function testRejectReusedNullifierDifferentUser() public {
        bytes32[4] memory publicInputs = [
            GLOBAL_ROOT,
            DISTRICT_ROOT_CA12,
            NULLIFIER_1,
            ACTION_ID_CONTACT
        ];

        // User1 verifies proof
        vm.prank(user1);
        gate.verifyDistrictMembership(MOCK_PROOF, publicInputs);

        // User2 tries to reuse same nullifier (should fail)
        vm.prank(user2);
        vm.expectRevert(
            abi.encodeWithSelector(DistrictGate.NullifierAlreadyUsed.selector, NULLIFIER_1)
        );
        gate.verifyDistrictMembership(MOCK_PROOF, publicInputs);
    }

    function testAllowDifferentNullifiers() public {
        // First proof with NULLIFIER_1
        bytes32[4] memory publicInputs1 = [
            GLOBAL_ROOT,
            DISTRICT_ROOT_CA12,
            NULLIFIER_1,
            ACTION_ID_CONTACT
        ];

        vm.prank(user1);
        bool result1 = gate.verifyDistrictMembership(MOCK_PROOF, publicInputs1);
        assertTrue(result1, "First proof should succeed");

        // Second proof with NULLIFIER_2 (different nullifier, should succeed)
        bytes32[4] memory publicInputs2 = [
            GLOBAL_ROOT,
            DISTRICT_ROOT_TX01,
            NULLIFIER_2,
            ACTION_ID_CONTACT
        ];

        vm.prank(user1);
        bool result2 = gate.verifyDistrictMembership(MOCK_PROOF, publicInputs2);
        assertTrue(result2, "Second proof with different nullifier should succeed");

        // Verify both nullifiers are marked as used
        assertTrue(gate.isNullifierUsed(NULLIFIER_1), "NULLIFIER_1 should be used");
        assertTrue(gate.isNullifierUsed(NULLIFIER_2), "NULLIFIER_2 should be used");
    }

    // ============================================================================
    // Shadow Atlas Root Validation Tests
    // ============================================================================

    function testRejectWrongGlobalRoot() public {
        bytes32 wrongRoot = bytes32(uint256(0x999999));
        bytes32[4] memory publicInputs = [
            wrongRoot,           // Wrong global root
            DISTRICT_ROOT_CA12,
            NULLIFIER_1,
            ACTION_ID_CONTACT
        ];

        vm.prank(user1);
        vm.expectRevert(
            abi.encodeWithSelector(
                DistrictGate.ShadowAtlasRootMismatch.selector,
                GLOBAL_ROOT,
                wrongRoot
            )
        );
        gate.verifyDistrictMembership(MOCK_PROOF, publicInputs);
    }

    function testAcceptProofAfterRootUpdate() public {
        // Update Shadow Atlas root
        bytes32 newRoot = bytes32(uint256(0x999999));
        vm.prank(owner);
        gate.updateShadowAtlasRoot(newRoot);

        // Proof with new root should succeed
        bytes32[4] memory publicInputs = [
            newRoot,
            DISTRICT_ROOT_CA12,
            NULLIFIER_1,
            ACTION_ID_CONTACT
        ];

        vm.prank(user1);
        bool result = gate.verifyDistrictMembership(MOCK_PROOF, publicInputs);
        assertTrue(result, "Proof with new root should succeed");
    }

    function testRejectProofWithOldRootAfterUpdate() public {
        // Update Shadow Atlas root
        bytes32 newRoot = bytes32(uint256(0x999999));
        vm.prank(owner);
        gate.updateShadowAtlasRoot(newRoot);

        // Proof with old root should fail
        bytes32[4] memory publicInputs = [
            GLOBAL_ROOT,  // Old root
            DISTRICT_ROOT_CA12,
            NULLIFIER_1,
            ACTION_ID_CONTACT
        ];

        vm.prank(user1);
        vm.expectRevert(
            abi.encodeWithSelector(
                DistrictGate.ShadowAtlasRootMismatch.selector,
                newRoot,
                GLOBAL_ROOT
            )
        );
        gate.verifyDistrictMembership(MOCK_PROOF, publicInputs);
    }

    // ============================================================================
    // Action Authorization Tests
    // ============================================================================

    function testRejectUnauthorizedAction() public {
        bytes32 unauthorizedAction = keccak256("unauthorized_action");
        bytes32[4] memory publicInputs = [
            GLOBAL_ROOT,
            DISTRICT_ROOT_CA12,
            NULLIFIER_1,
            unauthorizedAction
        ];

        vm.prank(user1);
        vm.expectRevert(
            abi.encodeWithSelector(
                DistrictGate.ActionNotAuthorized.selector,
                unauthorizedAction
            )
        );
        gate.verifyDistrictMembership(MOCK_PROOF, publicInputs);
    }

    function testAuthorizeNewAction() public {
        bytes32 newAction = keccak256("new_action");

        // Initially not authorized
        assertFalse(gate.isActionAuthorized(newAction), "Should not be authorized initially");

        // Authorize action
        vm.prank(owner);
        gate.authorizeAction(newAction);

        // Now authorized
        assertTrue(gate.isActionAuthorized(newAction), "Should be authorized after call");
    }

    function testDeauthorizeAction() public {
        // ACTION_ID_CONTACT is authorized in setUp
        assertTrue(gate.isActionAuthorized(ACTION_ID_CONTACT), "Should be authorized initially");

        // Deauthorize action
        vm.prank(owner);
        gate.deauthorizeAction(ACTION_ID_CONTACT);

        // Now deauthorized
        assertFalse(gate.isActionAuthorized(ACTION_ID_CONTACT), "Should be deauthorized");
    }

    function testBatchAuthorizeActions() public {
        bytes32[] memory actions = new bytes32[](3);
        actions[0] = keccak256("action1");
        actions[1] = keccak256("action2");
        actions[2] = keccak256("action3");

        vm.prank(owner);
        gate.batchAuthorizeActions(actions);

        // Verify all authorized
        assertTrue(gate.isActionAuthorized(actions[0]), "Action 1 should be authorized");
        assertTrue(gate.isActionAuthorized(actions[1]), "Action 2 should be authorized");
        assertTrue(gate.isActionAuthorized(actions[2]), "Action 3 should be authorized");
    }

    // ============================================================================
    // Shadow Atlas Root Management Tests
    // ============================================================================

    function testUpdateShadowAtlasRoot() public {
        bytes32 newRoot = bytes32(uint256(0x999999));

        vm.prank(owner);
        gate.updateShadowAtlasRoot(newRoot);

        assertEq(gate.getShadowAtlasRoot(), newRoot, "Root should be updated");
    }

    function testOnlyOwnerCanUpdateRoot() public {
        bytes32 newRoot = bytes32(uint256(0x888888));

        vm.prank(user1); // Not owner
        vm.expectRevert(); // Ownable: caller is not the owner
        gate.updateShadowAtlasRoot(newRoot);
    }

    function testRejectZeroRoot() public {
        vm.prank(owner);
        vm.expectRevert("Invalid root");
        gate.updateShadowAtlasRoot(bytes32(0));
    }

    function testRejectUnchangedRoot() public {
        vm.prank(owner);
        vm.expectRevert("Root unchanged");
        gate.updateShadowAtlasRoot(GLOBAL_ROOT);
    }

    // ============================================================================
    // Batch Verification Tests
    // ============================================================================

    function testBatchVerifyMultipleProofs() public {
        bytes[] memory proofs = new bytes[](2);
        proofs[0] = MOCK_PROOF;
        proofs[1] = MOCK_PROOF;

        bytes32[4][] memory publicInputsArray = new bytes32[4][](2);
        publicInputsArray[0] = [
            GLOBAL_ROOT,
            DISTRICT_ROOT_CA12,
            NULLIFIER_1,
            ACTION_ID_CONTACT
        ];
        publicInputsArray[1] = [
            GLOBAL_ROOT,
            DISTRICT_ROOT_TX01,
            NULLIFIER_2,
            ACTION_ID_CONTACT
        ];

        vm.prank(user1);
        bool[] memory results = gate.batchVerifyDistrictMembership(proofs, publicInputsArray);

        assertEq(results.length, 2, "Should return 2 results");
        assertTrue(results[0], "First proof should succeed");
        assertTrue(results[1], "Second proof should succeed");
    }

    function testBatchVerifyRejectsReusedNullifier() public {
        bytes[] memory proofs = new bytes[](2);
        proofs[0] = MOCK_PROOF;
        proofs[1] = MOCK_PROOF;

        // Both use same nullifier (second should fail)
        bytes32[4][] memory publicInputsArray = new bytes32[4][](2);
        publicInputsArray[0] = [
            GLOBAL_ROOT,
            DISTRICT_ROOT_CA12,
            NULLIFIER_1,
            ACTION_ID_CONTACT
        ];
        publicInputsArray[1] = [
            GLOBAL_ROOT,
            DISTRICT_ROOT_TX01,
            NULLIFIER_1,  // Same nullifier
            ACTION_ID_CONTACT
        ];

        vm.prank(user1);
        bool[] memory results = gate.batchVerifyDistrictMembership(proofs, publicInputsArray);

        assertTrue(results[0], "First proof should succeed");
        assertFalse(results[1], "Second proof should fail (reused nullifier)");
    }

    function testBatchVerifyRequiresMatchingLengths() public {
        bytes[] memory proofs = new bytes[](2);
        proofs[0] = MOCK_PROOF;
        proofs[1] = MOCK_PROOF;

        bytes32[4][] memory publicInputsArray = new bytes32[4][](1); // Mismatched length

        vm.prank(user1);
        vm.expectRevert("Length mismatch");
        gate.batchVerifyDistrictMembership(proofs, publicInputsArray);
    }

    function testBatchVerifyRejectsEmptyBatch() public {
        bytes[] memory proofs = new bytes[](0);
        bytes32[4][] memory publicInputsArray = new bytes32[4][](0);

        vm.prank(user1);
        vm.expectRevert("Empty batch");
        gate.batchVerifyDistrictMembership(proofs, publicInputsArray);
    }

    // ============================================================================
    // Gas Profiling Tests
    // ============================================================================

    /// @notice Gas profiling for single verification
    /// @dev Run with: forge test --match-test testGasSingleVerification -vvv
    function testGasSingleVerification() public {
        bytes32[4] memory publicInputs = [
            GLOBAL_ROOT,
            DISTRICT_ROOT_CA12,
            NULLIFIER_1,
            ACTION_ID_CONTACT
        ];

        vm.prank(user1);
        uint256 gasBefore = gasleft();
        gate.verifyDistrictMembership(MOCK_PROOF, publicInputs);
        uint256 gasUsed = gasBefore - gasleft();

        // Log gas usage
        emit log_named_uint("Gas used for single verification", gasUsed);

        // Note: With real Halo2Verifier, expect 300-500k gas
        // MockVerifier uses much less (no pairing operations)
    }

    /// @notice Gas profiling for batch verification (10 proofs)
    /// @dev Run with: forge test --match-test testGasBatchVerification -vvv
    function testGasBatchVerification() public {
        uint256 batchSize = 10;
        bytes[] memory proofs = new bytes[](batchSize);
        bytes32[4][] memory publicInputsArray = new bytes32[4][](batchSize);

        for (uint256 i = 0; i < batchSize; i++) {
            proofs[i] = MOCK_PROOF;
            publicInputsArray[i] = [
                GLOBAL_ROOT,
                DISTRICT_ROOT_CA12,
                bytes32(uint256(i)), // Unique nullifier per proof
                ACTION_ID_CONTACT
            ];
        }

        vm.prank(user1);
        uint256 gasBefore = gasleft();
        gate.batchVerifyDistrictMembership(proofs, publicInputsArray);
        uint256 gasUsed = gasBefore - gasleft();

        emit log_named_uint("Gas used for batch verification (10 proofs)", gasUsed);
        emit log_named_uint("Average gas per proof", gasUsed / batchSize);
    }

    // ============================================================================
    // Access Control Tests
    // ============================================================================

    function testOnlyOwnerCanAuthorizeActions() public {
        bytes32 newAction = keccak256("new_action");

        vm.prank(user1); // Not owner
        vm.expectRevert(); // Ownable: caller is not the owner
        gate.authorizeAction(newAction);
    }

    function testOnlyOwnerCanDeauthorizeActions() public {
        vm.prank(user1); // Not owner
        vm.expectRevert(); // Ownable: caller is not the owner
        gate.deauthorizeAction(ACTION_ID_CONTACT);
    }

    function testOnlyOwnerCanBatchAuthorize() public {
        bytes32[] memory actions = new bytes32[](1);
        actions[0] = keccak256("action1");

        vm.prank(user1); // Not owner
        vm.expectRevert(); // Ownable: caller is not the owner
        gate.batchAuthorizeActions(actions);
    }

    // ============================================================================
    // View Function Tests
    // ============================================================================

    function testIsNullifierUsed() public {
        assertFalse(gate.isNullifierUsed(NULLIFIER_1), "Should not be used initially");

        // Use nullifier
        bytes32[4] memory publicInputs = [
            GLOBAL_ROOT,
            DISTRICT_ROOT_CA12,
            NULLIFIER_1,
            ACTION_ID_CONTACT
        ];
        vm.prank(user1);
        gate.verifyDistrictMembership(MOCK_PROOF, publicInputs);

        assertTrue(gate.isNullifierUsed(NULLIFIER_1), "Should be used after verification");
    }

    function testIsActionAuthorized() public {
        assertTrue(gate.isActionAuthorized(ACTION_ID_CONTACT), "Should be authorized (set in setUp)");

        bytes32 newAction = keccak256("new_action");
        assertFalse(gate.isActionAuthorized(newAction), "Should not be authorized (never added)");
    }
}
